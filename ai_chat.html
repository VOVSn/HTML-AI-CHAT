<!DOCTYPE html>
<!-- We need to have single html with styles and js ebmedded -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-translate-key="pageTitle">AI Chat</title>
    <style>
        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #e8e3d9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            transition: background-color 0.3s ease; /* Smooth transition for body background */
        }

        /* Main Chat Container */
        .chat-app {
            width: 800px; /* Desktop width */
            height: 650px; /* Desktop height */
            background: linear-gradient(145deg, #eae5db, #dcd7cd);
            border-radius: 20px; /* Slightly less rounded for desktop */
            box-shadow:
                15px 15px 35px #c4c0b7,
                -15px -15px 35px #fcf7ed;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: background 0.3s ease, box-shadow 0.3s ease; /* Smooth transitions */
        }

        /* Chat Header */
        .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between; /* To space out agent-info and settings button */
            padding: 20px 25px; /* Increased padding */
            background: linear-gradient(145deg, #eae5db, #e0dbd1);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            position: relative; /* For z-index context and settings panel positioning */
            z-index: 2; /* Higher than chat-app::before, content */
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        .header-icon-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(145deg, #e8e3d9, #d9d4ca);
            box-shadow:
                4px 4px 8px #cbc6bd,
                -4px -4px 8px #f5f0e5;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative; /* For hover effect */
        }
        .header-icon-button:active {
             box-shadow:
                inset 3px 3px 6px #cbc6bd,
                inset -3px -3px 6px #f5f0e5;
        }
        .header-icon-button svg {
            width: 20px;
            height: 20px;
            fill: #736b5e;
            transition: fill 0.3s ease;
        }


        .agent-info {
            flex-grow: 1; /* Allow agent-info to take available space */
            display: flex;
            align-items: center;
        }

        .agent-name {
            font-weight: bold;
            font-size: 20px;
            color: #5a5346;
            transition: color 0.3s ease;
        }

        .agent-status {
            font-size: 13px;
            color: #847c6f;
            margin-top: 2px;
            transition: color 0.3s ease;
        }
        .agent-status.reachable {
            color: #4CAF50; /* Green for reachable */
        }
        .agent-status.not-reachable {
            color: #F44336; /* Red for not reachable */
        }


        /* Settings Panel (Popup) */
        .settings-panel {
            position: absolute;
            top: 75px; /* Position below header */
            right: 25px; /* Align with header padding */
            width: 320px; 
            max-height: calc(100vh - 100px - 20px); /* Max height considering header and some padding */
            background: linear-gradient(145deg, #e8e3d9, #dcd7cd); 
            border-radius: 15px;
            box-shadow: 8px 8px 16px #c4c0b7, -8px -8px 16px #fcf7ed; 
            z-index: 10; 
            
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px) scale(0.95);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s linear 0.25s, background 0.3s ease, box-shadow 0.3s ease;
            pointer-events: none;
            display: flex; 
            flex-direction: column; 
        }

        .settings-panel.is-open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
            transition-delay: 0s, 0s, 0s;
            pointer-events: auto;
        }
        
        .settings-panel-content { /* New wrapper for all settings items */
            padding: 20px;
            flex-grow: 1;
            overflow-y: auto;
        }
        .settings-panel-content .settings-group-title:first-child {
            margin-top: 0; 
        }


        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 18px; 
        }
         .settings-row:last-child {
            margin-bottom: 0;
        }

        .settings-label {
            font-size: 14px;
            color: #5a5346;
            font-weight: 500;
            transition: color 0.3s ease;
            flex-shrink: 0; 
            margin-right: 10px;
        }
        .settings-panel select.settings-input { /* Kept for potential future selects */
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%235A5346%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22/%3E%3C/svg%3E');
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: .65em auto;
            padding-right: 30px; /* Make space for arrow */
        }


        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            flex-shrink: 0; 
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #dcd7cd;
            box-shadow:
                inset 2px 2px 4px #cbc6bd,
                inset -2px -2px 4px #f5f0e5;
            border-radius: 34px;
            transition: .4s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: linear-gradient(145deg, #f0ebe1, #e0dbd1);
            border-radius: 50%;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            transition: .4s;
        }

        input:checked + .toggle-slider {
            background: linear-gradient(145deg, #d5ccb8, #c6bdaa);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background: linear-gradient(145deg, #d9cebc, #c8beac);
        }

        /* New Settings Inputs and Button */
        .settings-group-title {
            font-size: 12px;
            color: #847c6f;
            text-transform: uppercase;
            margin-bottom: 12px;
            margin-top: 20px; 
            padding-bottom: 6px;
            border-bottom: 1px solid #c5bdab;
            transition: color 0.3s ease, border-color 0.3s ease;
        }
        .settings-input {
            flex-grow: 1; 
            padding: 8px 12px;
            border: none;
            border-radius: 10px;
            background: #e2ddd3; 
            color: #5a5346;
            outline: none;
            font-size: 13px;
            box-shadow:
                inset 2px 2px 4px #cbc6bd,
                inset -2px -2px 4px #f5f0e5; 
            border: 1px solid rgba(173, 157, 124, 0.05); 
            transition: background 0.3s ease, box-shadow 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            min-width: 0; 
        }
        .settings-input::placeholder {
            color: #a0988a; 
            transition: color 0.3s ease;
        }
        .settings-input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
        .settings-input[type="number"]::-webkit-inner-spin-button,
        .settings-input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }


        .settings-row.action-row { 
            justify-content: space-between; 
            align-items: center;
        }
        .settings-button {
            padding: 8px 12px;
            border-radius: 8px; 
            background: linear-gradient(145deg, #e8e3d9, #d9d4ca);
            box-shadow: 3px 3px 6px #cbc6bd, -3px -3px 6px #f5f0e5;
            color: #5a5346;
            font-size: 13px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .settings-button:active {
            box-shadow: inset 2px 2px 4px #cbc6bd, inset -2px -2px 4px #f5f0e5;
        }
        .settings-button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .settings-button.danger {
            background: linear-gradient(145deg, #e6c8c1, #d7b9b2);
            box-shadow: 3px 3px 6px #c2a8a1, -3px -3px 6px #fce8e1;
            color: #7c3f36;
        }
        .settings-button.danger:active {
            box-shadow: inset 2px 2px 4px #c2a8a1, inset -2px -2px 4px #fce8e1;
        }

        .status-text {
            font-size: 12px;
            text-align: right;
            flex-shrink: 0;
            margin-left: 10px; 
            transition: color 0.3s ease;
        }
        .status-text.checking { color: #847c6f; }
        .status-text.success { color: #4CAF50; font-weight: 500; }
        .status-text.error { color: #F44336; font-weight: 500; }


        /* Chat Messages Area */
        .chat-messages {
            flex: 1;
            padding: 20px 25px;
            overflow-y: auto;
            background: linear-gradient(125deg, #e6e1d7, #dbd6cc);
            box-shadow:
                inset 5px 5px 15px #cbc6bd,
                inset -5px -5px 15px #f5f0e5;
            display: flex;
            flex-direction: column;
            position: relative; 
            z-index: 1;
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        /* Base message style */
        .message {
            max-width: 70%; 
            padding: 9px 15px; 
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.4; 
            position: relative;
            word-wrap: break-word;
            transition: background 0.3s ease, box-shadow 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .message-content {
        }
         .message.user .message-content .image-indicator { 
            margin-right: 5px;
            font-size: 1.1em; 
        }
        .message-image-preview {
            max-width: 300px; /* Increased from 150px */
            max-height: 300px; /* Increased from 150px */
            border-radius: 8px;
            margin-bottom: 8px; 
            display: block; 
            background-color: #dcd7cd; /* Fallback bg for image loading */
            transition: background-color 0.3s ease;
        }
        .message-image-fallback-icon {
            width: 40px; 
            height: 40px; 
            fill: #847c6f; 
            margin-bottom: 8px;
            display: block;
            transition: fill 0.3s ease;
        }

        .message.ai .message-content ul, .message.ai .message-content ol {
            margin-left: 20px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .message.ai .message-content li {
            margin-bottom: 3px;
        }
         .message.ai .message-content p {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }
        .message.ai .message-content p:first-child {
            margin-top: 0;
        }
        .message.ai .message-content p:last-child {
            margin-bottom: 0;
        }
        .message.ai .message-content code { /* Basic styling for inline code */
            background-color: rgba(0,0,0,0.05);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }
        .message.ai .message-content pre { /* Basic styling for code blocks */
            background-color: rgba(0,0,0,0.05);
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 0.5em 0;
        }
        .message.ai .message-content pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 1em; /* Reset from inline */
        }


        /* User message style */
        .message.user {
            align-self: flex-end;
            background: linear-gradient(145deg, #d5ccb8, #c6bdaa);
            border-radius: 18px 18px 4px 18px;
            color: #5a5346;
            box-shadow:
                5px 5px 15px #b5ac9a,
                -5px -5px 15px #e5dcc8;
            border: 1px solid rgba(173, 157, 124, 0.2);
            position: relative;
            isolation: isolate; 
        }
        
        .message.user > div, .message.user > span, .message.user > ul {
            position: relative; 
        }
        .message.user ul { 
            padding-left: 20px; 
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .message.user li {
            margin-bottom: 3px;
        }

        /* AI message style */
        .message.ai {
            align-self: flex-start;
            background: linear-gradient(145deg, #e8e3d9, #dcd7cd);
            border-radius: 18px 18px 18px 4px;
            color: #5a5346;
            box-shadow:
                5px 5px 15px #cbc6bd,
                -5px -5px 15px #f5f0e5;
            border: 1px solid rgba(173, 157, 124, 0.1);
        }


        .message-time {
            font-size: 10px;
            color: #847c6f;
            margin-top: 5px;
            text-align: right;
            display: block; 
            transition: color 0.3s ease;
        }
        .message.ai .message-time {
            text-align: left;
        }

        /* System Message Style */
        .system-message {
            text-align: center;
            font-size: 12px;
            color: #847c6f; 
            margin: 15px 0;
            font-style: italic;
            transition: color 0.3s ease;
        }


        /* Date Separator */
        .date-separator {
            display: flex;
            align-items: center;
            margin: 20px 0;
            color: #847c6f;
            font-size: 12px;
            transition: color 0.3s ease;
        }

        .date-separator:before,
        .date-separator:after {
            content: "";
            flex: 1;
            border-bottom: 1px solid #c5bdab;
            transition: border-color 0.3s ease;
        }

        .date-separator:before {
            margin-right: 10px;
        }

        .date-separator:after {
            margin-left: 10px;
        }

        /* Chat Input Area */
        .chat-input-area {
            padding: 15px 25px; 
            background: linear-gradient(145deg, #e8e3d9, #dcd7cd);
            display: flex;
            flex-direction: column; 
            align-items: stretch; 
            border-top: 1px solid rgba(173, 157, 124, 0.1);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.03);
            position: relative; 
            z-index: 1;
            transition: background 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
        }
        .input-controls-row {
            display: flex;
            align-items: center;
            width: 100%;
        }


        /* Image Preview Styles */
        #imagePreviewContainer {
            padding: 5px;
            background: #e2ddd3;
            border-radius: 12px;
            box-shadow: inset 1px 1px 3px #cbc6bd, inset -1px -1px 3px #f5f0e5;
            display: inline-block; 
            max-width: calc(100% - 40px); 
            margin-bottom: 10px; 
            align-self: flex-start; 
            position: relative;
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }
        #imagePreview {
            display: block;
            max-width: 200px; /* Increased from 100px */
            max-height: 200px; /* Increased from 100px */
            border-radius: 8px;
            background-color: #dcd7cd; /* Fallback bg for image loading */
            transition: background-color 0.3s ease;
        }
        #removeImageBtn {
            position: absolute;
            top: -8px; 
            right: -8px; 
            background: #e8e3d9;
            color: #a5584c;
            border: none;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            cursor: pointer;
            font-size: 15px;
            line-height: 20px;
            text-align: center;
            font-weight: bold;
            box-shadow: 2px 2px 5px #cbc6bd, -2px -2px 5px #f5f0e5;
            transition: all 0.2s ease;
        }
        #removeImageBtn:active {
            box-shadow: inset 1px 1px 2px #cbc6bd, inset -1px -1px 2px #f5f0e5;
        }

        .additional-buttons {
            display: flex;
            gap: 15px;
            margin-right: 15px;
        }

        .circle-button {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(145deg, #e8e3d9, #d9d4ca);
            box-shadow:
                4px 4px 8px #cbc6bd,
                -4px -4px 8px #f5f0e5;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid rgba(173, 157, 124, 0.1);
            position: relative;
        }

        .circle-button:active {
            box-shadow:
                inset 3px 3px 6px #cbc6bd,
                inset -3px -3px 6px #f5f0e5;
        }
         .circle-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow:
                inset 2px 2px 4px #cbc6bd,
                inset -2px -2px 4px #f5f0e5;
        }

        .attachment-icon svg { 
            width: 20px;
            height: 20px;
            fill: #847c6f;
            transition: fill 0.3s ease;
        }
        
        .chat-input {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 22px;
            background: #e2ddd3;
            color: #5a5346;
            outline: none;
            font-size: 14px;
            box-shadow:
                inset 4px 4px 8px #cbc6bd,
                inset -4px -4px 8px #f5f0e5;
            border: 1px solid rgba(173, 157, 124, 0.1);
            transition: background 0.3s ease, box-shadow 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            width: 100%; 
        }
         .chat-input::placeholder {
            color: #847c6f;
            transition: color 0.3s ease;
        }


        .send-button { 
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d9cebc, #c8beac); 
            box-shadow:
                4px 4px 8px #b5ac9a,   
                -4px -4px 8px #e5dcc8;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            margin-left: 10px; 
            transition: all 0.2s ease;
            border: 1px solid rgba(173, 157, 124, 0.2); 
            position: relative;
            flex-shrink: 0; 
        }


        .send-button:active {
            box-shadow:
                inset 3px 3px 6px #b5ac9a, 
                inset -3px -3px 6px #e5dcc8;
        }
         .send-button:disabled { 
            opacity: 0.6;
            cursor: not-allowed;
             box-shadow:
                inset 2px 2px 4px #cbc6bd, 
                inset -2px -2px 4px #f5f0e5;
        }

        .send-icon {
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-left: 12px solid #5a5346;
            margin-left: 4px;
            transition: border-left-color 0.3s ease;
        }

        /* Custom Scrollbar */
        .chat-messages::-webkit-scrollbar,
        .settings-panel-content::-webkit-scrollbar { /* Apply to settings panel content too */
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track,
        .settings-panel-content::-webkit-scrollbar-track {
            background: transparent;
            margin: 5px 0;
        }

        .chat-messages::-webkit-scrollbar-thumb,
        .settings-panel-content::-webkit-scrollbar-thumb {
            background-color: #c5bdab;
            border-radius: 10px;
            border: 2px solid transparent;
            transition: background-color 0.3s ease;
        }
        .chat-messages::-webkit-scrollbar-thumb:hover,
        .settings-panel-content::-webkit-scrollbar-thumb:hover {
            background-color: #b9b1a0;
        }


        /* Golden shimmer effect for chat app background */
        .chat-app::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                45deg,
                transparent 0%,
                rgba(255, 215, 0, 0.03) 25%,
                rgba(255, 215, 0, 0.06) 50%,
                rgba(255, 215, 0, 0.03) 75%,
                transparent 100%
            );
            border-radius: 20px;
            z-index: 0;
            pointer-events: none;
            transition: background 0.3s ease;
        }

        /* Shimmer effect for buttons on hover */
        .circle-button::before,
        .send-button::before,
        .header-icon-button::before,
        .settings-button::before { 
            content: "";
            position: absolute;
            inset: -1px;
            border-radius: inherit;
            background: linear-gradient(
                135deg,
                transparent 30%,
                rgba(255, 215, 0, 0.15) 50%,
                transparent 70%
            );
            opacity: 0;
            transition: opacity 0.3s, background 0.3s ease;
            z-index: -1; 
            pointer-events: none;
        }

        .circle-button:hover::before,
        .send-button:hover::before,
        .header-icon-button:hover::before,
        .settings-button:hover::before { 
            opacity: 1;
        }
         .circle-button:disabled::before,
        .send-button:disabled::before {
            opacity: 0 !important;
        }


        /* --- Dark Mode Styles --- */
        body.dark-mode {
            background-color: #2a2c31;
        }

        .dark-mode .chat-app {
            background: linear-gradient(145deg, #3a3d42, #2f3136);
            box-shadow: 15px 15px 30px #25272b, -15px -15px 30px #45494f;
        }

        .dark-mode .chat-header {
            background: linear-gradient(145deg, #383b40, #2e3035);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .dark-mode .agent-name { color: #e0e0e0; }
        .dark-mode .agent-status { color: #a0a0a0; }
        /* .agent-status.reachable/not-reachable colors are absolute, so they remain */

        .dark-mode .header-icon-button {
            background: linear-gradient(145deg, #36393f, #2c2e33);
            box-shadow: 4px 4px 8px #232528, -4px -4px 8px #43474c;
        }
        .dark-mode .header-icon-button svg { fill: #b0b0b0; }
        .dark-mode .header-icon-button:active {
            box-shadow: inset 3px 3px 6px #232528, inset -3px -3px 6px #43474c;
        }

        .dark-mode .settings-panel {
            background: linear-gradient(145deg, #3a3d42, #2f3136);
            box-shadow: 8px 8px 16px #25272b, -8px -8px 16px #45494f;
        }
        .dark-mode .settings-label { color: #c0c0c0; }
        .dark-mode .settings-group-title {
            color: #909090;
            border-bottom-color: #4a4d52;
        }
        .dark-mode .settings-input {
            background: #303338;
            color: #d0d0d0;
            box-shadow: inset 2px 2px 4px #26282c, inset -2px -2px 4px #3a3c40;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        .dark-mode .settings-input::placeholder { color: #707070; }
        .dark-mode .settings-panel select.settings-input {
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23B0B0B0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22/%3E%3C/svg%3E');
        }


        .dark-mode .toggle-slider {
            background: #2f3136;
            box-shadow: inset 2px 2px 4px #25272b, inset -2px -2px 4px #45494f;
        }
        .dark-mode .toggle-slider:before {
            background: linear-gradient(145deg, #404348, #303237);
        }
        .dark-mode input:checked + .toggle-slider {
            background: linear-gradient(145deg, #527FFF, #4065CC); /* Using a blue accent for checked toggles in dark mode */
        }
        .dark-mode input:checked + .toggle-slider:before {
            background: linear-gradient(145deg, #608BFF, #5075DD);
        }

        .dark-mode .settings-button {
            background: linear-gradient(145deg, #36393f, #2c2e33);
            box-shadow: 3px 3px 6px #232528, -3px -3px 6px #43474c;
            color: #c0c0c0;
        }
        .dark-mode .settings-button:active {
            box-shadow: inset 2px 2px 4px #232528, inset -2px -2px 4px #43474c;
        }
        .dark-mode .settings-button.danger {
            background: linear-gradient(145deg, #5e3939, #4e2f2f);
            box-shadow: 3px 3px 6px #3e2020, -3px -3px 6px #6e4848;
            color: #f0b0b0;
        }
        .dark-mode .settings-button.danger:active {
            box-shadow: inset 2px 2px 4px #3e2020, inset -2px -2px 4px #6e4848;
        }

        .dark-mode .status-text.checking { color: #a0a0a0; }
        .dark-mode .status-text.success { color: #66bb6a; }
        .dark-mode .status-text.error { color: #ef5350; }

        .dark-mode .chat-messages {
            background: linear-gradient(125deg, #33363b, #2b2d31);
            box-shadow: inset 5px 5px 15px #232528, inset -5px -5px 15px #404449;
        }
        .dark-mode .message { color: #d0d0d0; } /* Default text color inside messages */
        
        .dark-mode .message-image-preview { background-color: #2b2d31; }
        .dark-mode .message-image-fallback-icon { fill: #808080; }

        .dark-mode .message.ai .message-content code {
            background-color: #282a2e; /* Slightly darker than message bg */
            color: #cccccc; 
            border: 1px solid #3a3d42;
        }
        .dark-mode .message.ai .message-content pre {
            background-color: #25272b; /* Even darker for block */
            color: #cccccc;
            border: 1px solid #3a3d42;
        }
        .dark-mode .message.ai .message-content pre code {
            background-color: transparent;
            border: none;
        }


        .dark-mode .message.user {
            background: linear-gradient(145deg, #4a5058, #3e434a);
            color: #e0e0e0;
            box-shadow: 5px 5px 15px #303338, -5px -5px 15px #50555d;
            border: 1px solid rgba(0,0,0, 0.3);
        }
        .dark-mode .message.ai {
            background: linear-gradient(145deg, #3c3f45, #32353a);
            color: #d0d0d0;
            box-shadow: 5px 5px 15px #282a2e, -5px -5px 15px #484c52;
            border: 1px solid rgba(0,0,0, 0.2);
        }
        .dark-mode .message-time { color: #808080; }
        .dark-mode .system-message { color: #909090; }
        
        .dark-mode .date-separator { color: #808080; }
        .dark-mode .date-separator:before, .dark-mode .date-separator:after {
            border-bottom-color: #4a4d52;
        }

        .dark-mode .chat-input-area {
            background: linear-gradient(145deg, #383b40, #2e3035);
            border-top: 1px solid rgba(0,0,0, 0.2);
            box-shadow: 0 -2px 8px rgba(0,0,0,0.15);
        }
        .dark-mode #imagePreviewContainer {
            background: #303338;
            box-shadow: inset 1px 1px 3px #26282c, inset -1px -1px 3px #3a3c40;
        }
        .dark-mode #imagePreview { background-color: #2b2d31; }
        .dark-mode #removeImageBtn {
            background: #383b40;
            color: #d48075;
            box-shadow: 2px 2px 5px #232528, -2px -2px 5px #43474c;
        }
        .dark-mode #removeImageBtn:active {
            box-shadow: inset 1px 1px 2px #232528, inset -1px -1px 2px #43474c;
        }

        .dark-mode .circle-button {
            background: linear-gradient(145deg, #36393f, #2c2e33);
            box-shadow: 4px 4px 8px #232528, -4px -4px 8px #43474c;
            border: 1px solid rgba(0,0,0, 0.2);
        }
        .dark-mode .circle-button:active {
            box-shadow: inset 3px 3px 6px #232528, inset -3px -3px 6px #43474c;
        }
        .dark-mode .circle-button:disabled {
            box-shadow: inset 2px 2px 4px #232528, inset -2px -2px 4px #43474c;
        }
        .dark-mode .attachment-icon svg { fill: #a0a0a0; }
        
        .dark-mode .chat-input {
            background: #303338;
            color: #d0d0d0;
            box-shadow: inset 4px 4px 8px #26282c, inset -4px -4px 8px #3a3c40;
            border: 1px solid rgba(0,0,0, 0.1);
        }
        .dark-mode .chat-input::placeholder { color: #808080; }
        
        .dark-mode .send-button {
            background: linear-gradient(145deg, #4a5058, #3e434a);
            box-shadow: 4px 4px 8px #303338, -4px -4px 8px #50555d;
            border: 1px solid rgba(0,0,0, 0.3);
        }
        .dark-mode .send-button:active {
            box-shadow: inset 3px 3px 6px #303338, inset -3px -3px 6px #50555d;
        }
        .dark-mode .send-button:disabled {
            box-shadow: inset 2px 2px 4px #232528, inset -2px -2px 4px #43474c;
        }
        .dark-mode .send-icon { border-left-color: #d0d0d0; }

        .dark-mode .chat-messages::-webkit-scrollbar-thumb, 
        .dark-mode .settings-panel-content::-webkit-scrollbar-thumb {
            background-color: #50555d;
        }
        .dark-mode .chat-messages::-webkit-scrollbar-thumb:hover,
        .dark-mode .settings-panel-content::-webkit-scrollbar-thumb:hover {
            background-color: #60666e;
        }

        /* Dark Mode Shimmer */
        .dark-mode .chat-app::before {
            background: linear-gradient(
                45deg,
                transparent 0%,
                rgba(255, 255, 255, 0.015) 25%, /* Lighter, less saturated shimmer */
                rgba(255, 255, 255, 0.03) 50%,
                rgba(255, 255, 255, 0.015) 75%,
                transparent 100%
            );
        }

        .dark-mode .circle-button::before,
        .dark-mode .send-button::before,
        .dark-mode .header-icon-button::before,
        .dark-mode .settings-button::before {
            background: linear-gradient(
                135deg,
                transparent 30%,
                rgba(255, 255, 255, 0.08) 50%, /* Lighter shimmer for buttons */
                transparent 70%
            );
        }

    </style>
</head>
<body>
    <div class="chat-app">
        <!-- Chat Header -->
        <div class="chat-header">
            <div class="agent-info">
                <div>
                    <div class="agent-name" data-translate-key="agentName">AI Assistant</div>
                    <div class="agent-status" data-translate-key="agentStatusActive">Active</div>
                </div>
            </div>
            <div class="header-icon-button" id="settingsButton" title="Settings">
                <svg viewBox="0 0 24 24" width="20" height="20">
                    <circle cx="12" cy="5" r="2"/>
                    <circle cx="12" cy="12" r="2"/>
                    <circle cx="12" cy="19" r="2"/>
                </svg>
            </div>
        </div>

        <!-- Settings Panel (Popup) - Combined View -->
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-panel-content">
                <div class="settings-row">
                    <div class="settings-label" data-translate-key="darkModeLabel">Dark Mode</div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="darkModeToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="settings-row">
                    <div class="settings-label" data-translate-key="streamResponsesLabel">Stream Responses</div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="streamResponsesToggle" checked="">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="settings-row">
                    <div class="settings-label" data-translate-key="markdownLabel">Use Markdown</div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="markdownToggle" checked="">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="settings-group-title" data-translate-key="ollamaStatusTitle">Ollama Status</div>
                <div class="settings-row action-row">
                    <button id="checkOllamaStatusBtn" class="settings-button" data-translate-key="checkOllamaBtn">Check Ollama</button>
                    <span id="ollamaStatusText" class="status-text"></span>
                </div>

                <div class="settings-group-title" data-translate-key="ollamaConfigTitle">Ollama Configuration</div>
                <div class="settings-row">
                    <label class="settings-label" for="ollamaEndpoint" data-translate-key="ollamaEndpointLabel">Endpoint URL</label>
                    <input type="text" id="ollamaEndpoint" class="settings-input" placeholder="http://localhost:11434/api/generate">
                </div>
                <div class="settings-row">
                    <label class="settings-label" for="ollamaModel" data-translate-key="ollamaModelLabel">Model Name</label>
                    <input type="text" id="ollamaModel" class="settings-input" placeholder="gemma3:4b">
                </div>
                <div class="settings-row">
                    <label class="settings-label" for="ollamaTemperature" data-translate-key="ollamaTemperatureLabel">Temperature</label>
                    <input type="number" id="ollamaTemperature" class="settings-input" min="0.1" max="1.0" step="0.1">
                </div>

                <div class="settings-group-title" data-translate-key="chatDataTitle">Chat Data</div>
                <div class="settings-row action-row">
                    <button id="clearChatHistoryBtn" class="settings-button danger" data-translate-key="clearChatHistoryBtn">Clear Chat History</button>
                </div>
            </div>
        </div>

        <!-- Chat Messages -->
        <div class="chat-messages">
            <!-- Messages will be appended here -->
        </div>

        <!-- Chat Input Area -->
        <div class="chat-input-area">
             <!-- Image Preview Area -->
            <div id="imagePreviewContainer" style="display: none;">
                <img id="imagePreview" src="#" alt="Image preview"/>
                <button id="removeImageBtn" title="Remove image">×</button>
            </div>
            <input type="file" id="imageUpload" accept="image/*" style="display: none;">

            <div class="input-controls-row">
                <div class="additional-buttons">
                    <div class="circle-button" id="attachFileBtn" title="Upload Image">
                        <div class="attachment-icon">
                            <svg viewBox="0 0 24 24"> 
                                <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
                            </svg>
                        </div>
                    </div>
                </div>

                <input type="text" class="chat-input" placeholder="Ask the AI something...">

                <div class="send-button" title="Send Message">
                    <div class="send-icon"></div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <script>
        // --- Translations (English Only) ---
        const translations = {
            en: {
                pageTitle: "AI Chat",
                agentName: "AI Assistant",
                agentStatusActive: "Active",
                agentStatusTyping: "Typing...",
                agentStatusNotReachable: "Not Reachable",
                settingsTitle: "Settings", 
                darkModeLabel: "Dark Mode",
                streamResponsesLabel: "Stream Responses",
                markdownLabel: "Use Markdown",
                ollamaStatusTitle: "Ollama Status",
                ollamaConfigTitle: "Ollama Configuration",
                ollamaEndpointLabel: "Endpoint URL",
                ollamaModelLabel: "Model Name",
                ollamaTemperatureLabel: "Temperature (0.1-1.0)",
                checkOllamaBtn: "Check Ollama",
                chatDataTitle: "Chat Data",
                clearChatHistoryBtn: "Clear Chat History",
                ollamaEndpointPlaceholder: "http://localhost:11434/api/generate",
                ollamaModelPlaceholder: "gemma3:4b", 
                ollamaStatusChecking: "Checking...",
                ollamaStatusRunning: "Ollama Running",
                ollamaStatusOKUnexpected: "Reachable (OK, unexpected content)",
                ollamaStatusReachableWithCode: "Reachable (Status: {status})",
                ollamaStatusNotReachable: "Not Reachable",
                ollamaStatusInvalidURL: "Invalid URL",
                attachFileTitle: "Upload Image", 
                chatInputPlaceholder: "Ask the AI something...",
                sendMessageTitle: "Send Message",
                dateToday: "Today",
                dateYesterday: "Yesterday",
                systemMsgLoadedFromFile: "Loaded history from chat_history.json. Copied to browser storage for this session.",
                systemMsgLoadedFromStorage: "Loaded history from browser's local storage.",
                systemMsgNoHistory: "No chat history found. Start chatting to save messages!",
                systemMsgHistoryCleared: "Chat history has been cleared. Start a new conversation!",
                ollamaError: "Error communicating with AI: {error}",
                confirmClearHistory: "Are you sure you want to clear all chat history from your browser's storage? This action cannot be undone.",
                ollamaPromptSystem: "You are a helpful AI assistant. The user is communicating in English. Your task is to provide a helpful and concise response to the user's current query, strictly in English. Use Markdown for formatting if appropriate (e.g., lists, bold, italics). If an image is provided, analyze it in conjunction with the text prompt.",
                ollamaPromptUserLabel: "User",
                ollamaPromptAiLabel: "AI",
                userImagePreviewAlt: "User image preview"
            }
        };
        const currentLanguage = 'en'; 

        // --- DOM Elements ---
        const settingsButton = document.getElementById('settingsButton');
        const settingsPanel = document.getElementById('settingsPanel');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const markdownToggle = document.getElementById('markdownToggle');
        const streamResponsesToggle = document.getElementById('streamResponsesToggle');
        const body = document.body;
        const ollamaEndpointInput = document.getElementById('ollamaEndpoint');
        const ollamaModelInput = document.getElementById('ollamaModel');
        const ollamaTemperatureInput = document.getElementById('ollamaTemperature');
        const checkOllamaStatusBtn = document.getElementById('checkOllamaStatusBtn');
        const ollamaStatusText = document.getElementById('ollamaStatusText');
        const clearChatHistoryBtn = document.getElementById('clearChatHistoryBtn');
        const chatMessagesContainer = document.querySelector('.chat-messages');
        const sendButton = document.querySelector('.send-button');
        const chatInput = document.querySelector('.chat-input');
        const agentNameDiv = document.querySelector('.agent-name');
        const agentStatusDiv = document.querySelector('.agent-status');
        
        const attachFileBtn = document.getElementById('attachFileBtn');
        const imageUpload = document.getElementById('imageUpload');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePreview = document.getElementById('imagePreview');
        const removeImageBtn = document.getElementById('removeImageBtn');
        
        // --- Constants for LocalStorage and Ollama ---
        const OLLAMA_ENDPOINT_KEY = 'ollamaUserEndpoint';
        const OLLAMA_MODEL_KEY = 'ollamaUserModel';
        const OLLAMA_TEMPERATURE_KEY = 'ollamaTemperatureSetting';
        const DEFAULT_OLLAMA_TEMPERATURE = 0.3;
        const CHAT_HISTORY_KEY = 'AiChatHistory';
        const MARKDOWN_ENABLED_KEY = 'aiChatMarkdownEnabled';
        const DARK_MODE_KEY = 'aiChatDarkModeEnabled';
        const MAX_HISTORY_FOR_PROMPT = 6; 
        const OLLAMA_CHECK_INTERVAL = 60000; 
        const PREVIEW_IMAGE_MAX_DIMENSION_PX = 300; // For chat history display
        const OLLAMA_IMAGE_MAX_DIMENSION_PX = 512;  // For sending to Ollama (adjust as needed, 400-768 is common)
        const IMAGE_QUALITY_PREVIEW = 0.85;
        const IMAGE_QUALITY_OLLAMA = 0.9;


        // --- Application State ---
        let isCheckingOllama = false; 
        let lastMessageDateString = '';
        let isAiResponding = false;
        let ollamaHeaderCheckIntervalId = null;
        let isOllamaReachableForHeader = true; 
        
        let currentOriginalImageBase64DataUri = null; 
        let currentResizedPreviewDataUri = null; // For chat history display

        // --- Translation Functions ---
        function getTranslation(key, replacements = {}) {
            let translation = translations[currentLanguage]?.[key] || key; 
            for (const placeholder in replacements) {
                translation = translation.replace(`{${placeholder}}`, replacements[placeholder]);
            }
            return translation;
        }
        
        function applyTranslations() {
            document.querySelectorAll('[data-translate-key]').forEach(el => {
                const key = el.dataset.translateKey;
                if (el.tagName === 'INPUT' && el.type === 'button' || el.tagName === 'BUTTON') {
                    el.value = getTranslation(key); 
                    el.textContent = getTranslation(key); 
                } else if (el.hasAttribute('placeholder') && el.tagName === 'INPUT') {
                    // Placeholders are handled specifically below if needed, or rely on HTML
                } else if (el.tagName === 'TITLE') {
                    el.textContent = getTranslation(key);
                }
                else {
                    el.textContent = getTranslation(key);
                }
            });
            
            if (document.querySelector('title')) {
                 document.querySelector('title').textContent = getTranslation('pageTitle');
            }
            if (agentNameDiv) agentNameDiv.textContent = getTranslation('agentName');
            setAgentStatus(isAiResponding ? 'typing' : 'active'); // Will update based on reachability if active

            if (settingsButton) settingsButton.title = getTranslation('settingsTitle');
            
            if (ollamaEndpointInput) ollamaEndpointInput.placeholder = getTranslation('ollamaEndpointPlaceholder');
            if (ollamaModelInput) ollamaModelInput.placeholder = getTranslation('ollamaModelPlaceholder');
            
            if (attachFileBtn) attachFileBtn.title = getTranslation('attachFileTitle');
            if (chatInput) chatInput.placeholder = getTranslation('chatInputPlaceholder');
            if (sendButton) sendButton.title = getTranslation('sendMessageTitle');

            // Re-apply status text translation if it was set
            if (ollamaStatusText && ollamaStatusText.dataset.key) {
                const currentStatusKey = ollamaStatusText.dataset.key;
                const currentReplacements = JSON.parse(ollamaStatusText.dataset.replacements || '{}');
                ollamaStatusText.textContent = getTranslation(currentStatusKey, currentReplacements);
            } else if (ollamaStatusText && !ollamaStatusText.textContent) { 
                 ollamaStatusText.textContent = ''; // Default to empty
            }
            if (!isAiResponding) { // Ensure header status is correct after translations
                updateAgentHeaderStatus();
            }
        }


        // --- Utility Functions ---
        function scrollToBottom() {
            if (chatMessagesContainer) {
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }
        }

        function updateAgentHeaderStatus() {
            if (agentStatusDiv) {
                agentStatusDiv.classList.remove('reachable', 'not-reachable');
                if (isOllamaReachableForHeader) {
                    agentStatusDiv.textContent = getTranslation('agentStatusActive');
                    agentStatusDiv.classList.add('reachable');
                } else {
                    agentStatusDiv.textContent = getTranslation('agentStatusNotReachable');
                    agentStatusDiv.classList.add('not-reachable');
                }
            }
        }

        function setAgentStatus(statusKey) { // 'typing' or 'active'
            if (agentStatusDiv) {
                agentStatusDiv.classList.remove('reachable', 'not-reachable'); // Clear previous status styles
                if (statusKey === 'typing') {
                    agentStatusDiv.textContent = getTranslation('agentStatusTyping');
                } else { // 'active' implies checking reachability
                    updateAgentHeaderStatus();
                }
            }
        }

        // --- Settings Panel Logic ---
        if (settingsButton && settingsPanel) {
            settingsButton.addEventListener('click', function(event) {
                event.stopPropagation(); // Prevent click from immediately closing via document listener
                settingsPanel.classList.toggle('is-open');
            });
            // Close settings panel if clicked outside
            document.addEventListener('click', function(event) {
                if (settingsPanel.classList.contains('is-open')) {
                    const isClickInsidePanel = settingsPanel.contains(event.target);
                    const isClickOnButton = settingsButton.contains(event.target) || event.target === settingsButton;
                    if (!isClickInsidePanel && !isClickOnButton) {
                        settingsPanel.classList.remove('is-open');
                    }
                }
            });
        }
        
        // Button active state visual feedback
        const allInteractiveButtons = document.querySelectorAll('.circle-button, .send-button, .header-icon-button, .settings-button');
        allInteractiveButtons.forEach(button => {
            if (button.disabled) return; // Skip disabled buttons initially
            button.addEventListener('mousedown', () => { if(!button.disabled) button.classList.add('active')});
            button.addEventListener('mouseup', () => button.classList.remove('active'));
            button.addEventListener('mouseleave', () => button.classList.remove('active')); // Also remove on mouse leave
        });

        // --- Dark Mode ---
        function setDarkMode(enabled) {
            if (enabled) {
                body.classList.add('dark-mode');
                localStorage.setItem(DARK_MODE_KEY, 'true');
                if (darkModeToggle) darkModeToggle.checked = true;
            } else {
                body.classList.remove('dark-mode');
                localStorage.setItem(DARK_MODE_KEY, 'false');
                if (darkModeToggle) darkModeToggle.checked = false;
            }
        }
        if (darkModeToggle) {
            darkModeToggle.addEventListener('change', function() {
                setDarkMode(this.checked);
            });
        }


        if (markdownToggle) {
            markdownToggle.addEventListener('change', function() {
                localStorage.setItem(MARKDOWN_ENABLED_KEY, this.checked);
            });
        }

        // --- Ollama Settings Management ---
        function loadOllamaSettings() {
            if (ollamaEndpointInput) {
                ollamaEndpointInput.value = localStorage.getItem(OLLAMA_ENDPOINT_KEY) || 'http://localhost:11434/api/generate';
            }
            if (ollamaModelInput) {
                ollamaModelInput.value = localStorage.getItem(OLLAMA_MODEL_KEY) || 'gemma3:4b'; 
            }
            if (ollamaTemperatureInput) {
                const storedTemp = localStorage.getItem(OLLAMA_TEMPERATURE_KEY);
                let tempToSet = DEFAULT_OLLAMA_TEMPERATURE;
                if (storedTemp !== null) {
                    const parsed = parseFloat(storedTemp);
                    if (!isNaN(parsed) && parsed >= 0.1 && parsed <= 1.0) {
                        tempToSet = parsed;
                    }
                }
                ollamaTemperatureInput.value = tempToSet.toFixed(1);
                // Ensure localStorage reflects the validated or default value
                localStorage.setItem(OLLAMA_TEMPERATURE_KEY, tempToSet.toFixed(1));
            }
        }

        function saveOllamaSetting(key, value) {
            localStorage.setItem(key, value);
        }

        if (ollamaEndpointInput) {
            ollamaEndpointInput.addEventListener('input', () => saveOllamaSetting(OLLAMA_ENDPOINT_KEY, ollamaEndpointInput.value));
        }
        if (ollamaModelInput) {
            ollamaModelInput.addEventListener('input', () => saveOllamaSetting(OLLAMA_MODEL_KEY, ollamaModelInput.value));
        }
        if (ollamaTemperatureInput) {
            ollamaTemperatureInput.addEventListener('change', () => {
                let tempValue = parseFloat(ollamaTemperatureInput.value);
                if (isNaN(tempValue) || tempValue < 0.1) tempValue = 0.1;
                else if (tempValue > 1.0) tempValue = 1.0;
                
                ollamaTemperatureInput.value = tempValue.toFixed(1);
                saveOllamaSetting(OLLAMA_TEMPERATURE_KEY, tempValue.toFixed(1));
            });
        }

        function setOllamaStatusPanelText(key, replacements = {}, typeClass = '') { 
            if(!ollamaStatusText) return;
            ollamaStatusText.textContent = getTranslation(key, replacements);
            ollamaStatusText.className = `status-text ${typeClass}`; // Reset classes then add
            ollamaStatusText.dataset.key = key; // Store key for re-translation if needed
            ollamaStatusText.dataset.replacements = JSON.stringify(replacements);
        }
        
        async function _performOllamaReachabilityTest() {
            const endpointUrlFromInput = (ollamaEndpointInput ? ollamaEndpointInput.value.trim() : '') || 'http://localhost:11434/api/generate';
            let ollamaBaseUrlToTest;
            try {
                const parsedUrl = new URL(endpointUrlFromInput);
                ollamaBaseUrlToTest = parsedUrl.origin; // Test the root of the Ollama server
            } catch (e) {
                console.warn("Invalid Ollama endpoint URL:", endpointUrlFromInput, e);
                return { reachable: false, errorType: 'invalid_url' };
            }

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5-second timeout
                
                const response = await fetch(ollamaBaseUrlToTest, { method: 'GET', mode: 'cors', signal: controller.signal });
                clearTimeout(timeoutId);

                if (response.ok) {
                    const responseText = await response.text();
                    // Check if the response indicates Ollama is running (common response text)
                    if (responseText.toLowerCase().includes("ollama is running")) {
                       return { reachable: true, status: 'running' };
                    } else {
                       // Ollama is reachable, but the root page content is unexpected
                       return { reachable: true, status: 'ok_unexpected_content' };
                    }
                } else {
                    // HTTP error (e.g., 404, 500)
                    return { reachable: false, errorType: 'http_error', statusCode: response.status };
                }
            } catch (error) {
                console.warn('Ollama reachability test failed:', error);
                // Network error or fetch aborted
                 return { reachable: false, errorType: 'fetch_error', errorName: error.name };
            }
        }

        if (checkOllamaStatusBtn && ollamaStatusText) {
            checkOllamaStatusBtn.addEventListener('click', async () => {
                if (isCheckingOllama) return;
                isCheckingOllama = true;
                stopPeriodicOllamaHeaderCheck(); // Pause periodic checks during manual check
                setOllamaStatusPanelText('ollamaStatusChecking', {}, 'checking');
                checkOllamaStatusBtn.disabled = true;
                
                const result = await _performOllamaReachabilityTest();

                if (result.reachable) {
                    if (result.status === 'running') {
                        setOllamaStatusPanelText('ollamaStatusRunning', {}, 'success');
                    } else { // 'ok_unexpected_content'
                        setOllamaStatusPanelText('ollamaStatusOKUnexpected', {}, 'success');
                    }
                } else {
                    if (result.errorType === 'invalid_url') {
                        setOllamaStatusPanelText('ollamaStatusInvalidURL', {}, 'error');
                    } else if (result.errorType === 'http_error') {
                         setOllamaStatusPanelText('ollamaStatusReachableWithCode', { status: result.statusCode }, 'error');
                    } else { // 'fetch_error' or other
                        setOllamaStatusPanelText('ollamaStatusNotReachable', {}, 'error');
                    }
                }
                isOllamaReachableForHeader = result.reachable; // Update header status based on manual check
                updateAgentHeaderStatus();

                isCheckingOllama = false;
                checkOllamaStatusBtn.disabled = false;
                startPeriodicOllamaHeaderCheck(); // Resume periodic checks
                // Clear the status message after a few seconds
                setTimeout(() => { if (ollamaStatusText.dataset.key) setOllamaStatusPanelText('', {}, ''); }, 5000);
            });
        }
        
        async function checkOllamaForHeaderUpdate() {
            if (isAiResponding || isCheckingOllama) return; // Don't check if AI is busy or manual check is in progress

            const result = await _performOllamaReachabilityTest();
            isOllamaReachableForHeader = result.reachable;
            if (!isAiResponding) { // Only update header if AI is not currently typing
                 updateAgentHeaderStatus();
            }
        }

        function startPeriodicOllamaHeaderCheck() {
            if (ollamaHeaderCheckIntervalId) clearInterval(ollamaHeaderCheckIntervalId);
            ollamaHeaderCheckIntervalId = setInterval(checkOllamaForHeaderUpdate, OLLAMA_CHECK_INTERVAL);
        }

        function stopPeriodicOllamaHeaderCheck() {
            if (ollamaHeaderCheckIntervalId) clearInterval(ollamaHeaderCheckIntervalId);
            ollamaHeaderCheckIntervalId = null;
        }

        // --- Image Upload Handling ---
        async function resizeImage(originalDataUri, maxWidth, maxHeight, quality = 0.9, outputFormat = 'image/jpeg') {
            return new Promise((resolve, reject) => {
                if (!originalDataUri) {
                    reject(new Error("Original data URI is null or undefined."));
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    let width = img.width;
                    let height = img.height;

                    // Calculate new dimensions while maintaining aspect ratio
                    if (width > maxWidth || height > maxHeight) { // Only resize if larger
                        if (width / maxWidth > height / maxHeight) { // Width is the limiting factor
                            height = Math.round((height * maxWidth) / width);
                            width = maxWidth;
                        } else { // Height is the limiting factor or they are proportional
                            width = Math.round((width * maxHeight) / height);
                            height = maxHeight;
                        }
                    }
                    // Ensure dimensions are at least 1px to avoid canvas errors
                    width = Math.max(1, width);
                    height = Math.max(1, height);

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL(outputFormat, quality));
                };
                img.onerror = (err) => {
                    console.error("Image load error for resizing:", err, originalDataUri ? originalDataUri.substring(0,100) : "undefined URI");
                    reject(err); 
                };
                img.src = originalDataUri;
            });
        }

        async function generateResizedPreview(originalDataUri) {
            return resizeImage(originalDataUri, PREVIEW_IMAGE_MAX_DIMENSION_PX, PREVIEW_IMAGE_MAX_DIMENSION_PX, IMAGE_QUALITY_PREVIEW);
        }


        function clearSelectedImageState() {
            currentOriginalImageBase64DataUri = null;
            currentResizedPreviewDataUri = null;
            if(imagePreview) imagePreview.src = '#'; 
            if(imagePreviewContainer) imagePreviewContainer.style.display = 'none';
            if (imageUpload) imageUpload.value = ''; 
        }

        if (attachFileBtn && imageUpload && imagePreviewContainer && imagePreview && removeImageBtn) {
            attachFileBtn.addEventListener('click', () => {
                imageUpload.click();
            });

            imageUpload.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        currentOriginalImageBase64DataUri = e.target.result;
                        imagePreview.src = currentOriginalImageBase64DataUri; 
                        imagePreviewContainer.style.display = 'block';
                        currentResizedPreviewDataUri = null; 

                        try {
                            currentResizedPreviewDataUri = await generateResizedPreview(currentOriginalImageBase64DataUri);
                        } catch (error) {
                            console.error("Error generating resized preview for history:", error);
                            currentResizedPreviewDataUri = currentOriginalImageBase64DataUri; 
                        }
                    }
                    reader.readAsDataURL(file);
                } else {
                    clearSelectedImageState(); 
                }
            });

            removeImageBtn.addEventListener('click', () => {
                clearSelectedImageState();
            });
        }

        // --- Chat History and Messaging ---
        function displaySystemMessage(translationKey, replacements = {}) {
            const text = getTranslation(translationKey, replacements);
            const systemMessageDiv = document.createElement('div');
            systemMessageDiv.classList.add('system-message');
            systemMessageDiv.textContent = text;
            if(chatMessagesContainer) chatMessagesContainer.appendChild(systemMessageDiv);
            scrollToBottom();
        }

        function formatDateForDisplay(timestamp) {
            const date = new Date(timestamp);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);

            if (date.toDateString() === today.toDateString()) return getTranslation('dateToday');
            if (date.toDateString() === yesterday.toDateString()) return getTranslation('dateYesterday');
            
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
        }

        function addDateSeparator(timestamp) {
            const messageDate = new Date(timestamp);
            const messageDateStr = messageDate.toDateString(); 

            if (messageDateStr !== lastMessageDateString) {
                const separatorDiv = document.createElement('div');
                separatorDiv.classList.add('date-separator');
                const dateTextNode = document.createTextNode(formatDateForDisplay(timestamp));
                separatorDiv.appendChild(dateTextNode); 

                if(chatMessagesContainer) chatMessagesContainer.appendChild(separatorDiv);
                lastMessageDateString = messageDateStr;
            }
        }

        function formatAiMessageContent(text) {
            const useMarkdown = markdownToggle ? markdownToggle.checked : true;
            if (useMarkdown && typeof marked !== 'undefined') {
                return marked.parse(text, { breaks: true, gfm: true }); // Enable breaks for newlines
            } else {
                const tempDiv = document.createElement('div');
                tempDiv.textContent = text;
                return tempDiv.innerHTML.replace(/\n/g, '<br>');
            }
        }
        
        function renderMessageToDOM(messageData, isStreamingPlaceholder = false) {
            addDateSeparator(messageData.timestamp);

            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', messageData.type);

            const contentDiv = document.createElement('div');
            contentDiv.classList.add('message-content');

            let displayText = messageData.text || ""; 

            if (messageData.type === 'ai') {
                contentDiv.innerHTML = formatAiMessageContent(displayText.trim());
            } else if (messageData.type === 'user') {
                if (messageData.imageBase64) { 
                    const imgPreviewElement = document.createElement('img');
                    imgPreviewElement.src = messageData.imageBase64;
                    imgPreviewElement.alt = getTranslation('userImagePreviewAlt');
                    imgPreviewElement.classList.add('message-image-preview');
                    contentDiv.appendChild(imgPreviewElement);
                } else if (messageData.hasImage) { 
                    const svgIconNS = "http://www.w3.org/2000/svg";
                    const svgIcon = document.createElementNS(svgIconNS, "svg");
                    svgIcon.setAttribute("viewBox", "0 0 24 24");
                    svgIcon.classList.add('message-image-fallback-icon'); 
                    const path = document.createElementNS(svgIconNS, "path");
                    path.setAttribute("d", "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z");
                    svgIcon.appendChild(path);
                    contentDiv.appendChild(svgIcon);
                }
                
                if (displayText.trim()) { 
                    const textNode = document.createTextNode(displayText); 
                    contentDiv.appendChild(textNode);
                }
            } else { 
                contentDiv.textContent = displayText; 
            }
            messageDiv.appendChild(contentDiv);

            const timeDiv = document.createElement('div');
            timeDiv.classList.add('message-time');
            if (!isStreamingPlaceholder) { 
                timeDiv.textContent = new Date(messageData.timestamp).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
            }
            messageDiv.appendChild(timeDiv); 

            if(chatMessagesContainer) chatMessagesContainer.appendChild(messageDiv);
            return messageDiv;
        }

        function saveMessageToHistory(messageData) {
            const historyJson = localStorage.getItem(CHAT_HISTORY_KEY);
            const history = historyJson ? JSON.parse(historyJson) : [];
            history.push(messageData);
            try {
                localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(history));
            } catch (e) {
                console.error("Error saving history to localStorage (likely full):", e);
                displaySystemMessage("Error saving history: Storage might be full."); 
            }
        }

        function addNewMessage(text, type, hasImage = false, imageBase64ForHistory = null) {
            if (type !== 'ai' && (!text || (typeof text === 'string' && !text.trim())) && !hasImage ) {
                 return null; 
            }

            const messageData = {
                text: text, 
                type: type,
                hasImage: hasImage, 
                imageBase64: imageBase64ForHistory, 
                timestamp: Date.now()
            };
            
            const isPlaceholder = type === 'ai' && !text && (streamResponsesToggle ? streamResponsesToggle.checked : true);

            const messageElement = renderMessageToDOM(messageData, isPlaceholder);
            
            if (!isPlaceholder) { 
                saveMessageToHistory(messageData);
            }
            
            scrollToBottom();
            return messageElement;
        }

        async function loadChatHistory() {
            if (!chatMessagesContainer) return;
            chatMessagesContainer.innerHTML = ''; 
            lastMessageDateString = ''; 
            
            let historyActuallyLoaded = false;
            let systemMessageAlreadyShownAboutLoading = false;

            try {
                const response = await fetch('chat_history.json', { cache: "no-store" }); 
                if (response.ok) {
                    const historyFromFile = await response.json();
                    if (Array.isArray(historyFromFile) && historyFromFile.length > 0) {
                        historyFromFile.forEach(msgData => {
                            msgData.hasImage = msgData.hasImage || false;
                            msgData.imageBase64 = msgData.imageBase64 || null;
                            renderMessageToDOM(msgData);
                        }); 
                        historyActuallyLoaded = true;
                        localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(historyFromFile)); 
                        displaySystemMessage("systemMsgLoadedFromFile");
                        systemMessageAlreadyShownAboutLoading = true;
                    } else if (Array.isArray(historyFromFile) && historyFromFile.length === 0) {
                        console.info("chat_history.json is empty. Will try localStorage.");
                    } else {
                        console.warn("chat_history.json is not a valid history array. Will try localStorage.");
                    }
                } else if (response.status !== 404) { 
                    console.warn(`Error loading chat_history.json (status: ${response.status}). Will try localStorage.`);
                }
            } catch (error) { 
                console.info("Could not load chat_history.json (likely not present). Will try localStorage:", error.message);
            }

            if (!historyActuallyLoaded) {
                const historyFromStorageJson = localStorage.getItem(CHAT_HISTORY_KEY);
                if (historyFromStorageJson) {
                    try {
                        const historyFromStorage = JSON.parse(historyFromStorageJson);
                        if (Array.isArray(historyFromStorage) && historyFromStorage.length > 0) {
                            historyFromStorage.forEach(msgData => {
                                msgData.hasImage = msgData.hasImage || false;
                                msgData.imageBase64 = msgData.imageBase64 || null;
                                renderMessageToDOM(msgData)
                            }); 
                            historyActuallyLoaded = true;
                            if (!systemMessageAlreadyShownAboutLoading) {
                                displaySystemMessage("systemMsgLoadedFromStorage");
                                systemMessageAlreadyShownAboutLoading = true;
                            }
                        } else { 
                             console.info("Browser's local storage for chat history is empty or invalid array.");
                        }
                    } catch (e) { 
                        console.error("Error parsing history from local storage. Clearing it.", e);
                        localStorage.removeItem(CHAT_HISTORY_KEY); 
                    }
                }
            }
            
            if (!historyActuallyLoaded && !systemMessageAlreadyShownAboutLoading) {
                 displaySystemMessage("systemMsgNoHistory");
            }

            scrollToBottom();
        }

        if (clearChatHistoryBtn) {
            clearChatHistoryBtn.addEventListener('click', () => {
                if (confirm(getTranslation('confirmClearHistory'))) {
                    localStorage.removeItem(CHAT_HISTORY_KEY);
                    if(chatMessagesContainer) chatMessagesContainer.innerHTML = ''; 
                    lastMessageDateString = ''; 
                    displaySystemMessage("systemMsgHistoryCleared");
                    if (settingsPanel && settingsPanel.classList.contains('is-open')) {
                        settingsPanel.classList.remove('is-open'); 
                    }
                }
            });
        }

        // --- Ollama Integration ---
        function getChatHistoryForPrompt() {
            const historyJson = localStorage.getItem(CHAT_HISTORY_KEY);
            const history = historyJson ? JSON.parse(historyJson) : [];
            
            const recentMessages = history
                .filter(msg => msg.type === 'user' || msg.type === 'ai') 
                .slice(-MAX_HISTORY_FOR_PROMPT);

            const userLabel = getTranslation('ollamaPromptUserLabel');
            const aiLabel = getTranslation('ollamaPromptAiLabel');

            return recentMessages.map(msg => {
                const prefix = msg.type === 'user' ? userLabel : aiLabel;
                let messageContent = msg.text || ""; // Ensure text is at least an empty string
                if (msg.type === 'user' && msg.hasImage && !msg.text.trim()) { 
                    messageContent = `[${getTranslation('userImagePreviewAlt')}]`; 
                }
                return `${prefix}: ${messageContent}`;
            }).join('\n');
        }

        function constructOllamaPrompt(userInput, chatHistoryString, currentMessageHasImage) {
            const systemPrompt = getTranslation('ollamaPromptSystem');
            const userLabel = getTranslation('ollamaPromptUserLabel');
            const aiLabel = getTranslation('ollamaPromptAiLabel');

            let fullPrompt = `${systemPrompt}\n\n`;
            if (chatHistoryString) {
                fullPrompt += `Previous conversation:\n${chatHistoryString}\n\n`;
            }
            
            let currentUserInputLine = `${userLabel}: `;
            if (currentMessageHasImage) {
                // Add a more explicit marker if an image is provided with the current user input.
                // This helps the model associate the `images` payload with this specific turn.
                currentUserInputLine += `[Image Provided] `;
            }
            currentUserInputLine += (userInput || ""); // Ensure userInput is at least an empty string

            fullPrompt += `${currentUserInputLine}\n${aiLabel}:`;
            return fullPrompt;
        }

        async function callOllamaApi(promptText, onTokenCallback, imageBase64Payload = null) { 
            const endpoint = (ollamaEndpointInput ? ollamaEndpointInput.value : null) || 'http://localhost:11434/api/generate';
            const model = (ollamaModelInput ? ollamaModelInput.value : null) || 'gemma3:4b';
            const stream = streamResponsesToggle ? streamResponsesToggle.checked : true;

            let temperatureValue = DEFAULT_OLLAMA_TEMPERATURE;
            if (ollamaTemperatureInput) {
                const parsedTemp = parseFloat(ollamaTemperatureInput.value);
                if (!isNaN(parsedTemp) && parsedTemp >= 0.1 && parsedTemp <= 1.0) {
                    temperatureValue = parsedTemp;
                }
            }

            const requestPayload = {
                model: model,
                prompt: promptText,
                stream: stream,
                options: {
                    temperature: temperatureValue
                }
            };

            if (imageBase64Payload) {
                requestPayload.images = [imageBase64Payload]; // imageBase64Payload is just the base64 string
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestPayload),
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: "Unknown error structure" }));
                    throw new Error(`Ollama API Error: ${response.status} - ${errorData.error || response.statusText}`);
                }

                if (stream && response.body) {
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value, { stream: true });
                        const lines = chunk.split('\n').filter(line => line.trim() !== '');
                        for (const line of lines) {
                            try {
                                const jsonResponse = JSON.parse(line);
                                if (jsonResponse.response) {
                                    onTokenCallback(jsonResponse.response); 
                                }
                                if (jsonResponse.done) { 
                                    return; 
                                }
                            } catch (e) {
                                console.warn("Error parsing streamed JSON line:", line, e);
                            }
                        }
                    }
                    return; 
                } else { 
                    const data = await response.json();
                    return data.response; 
                }
            } catch (error) {
                console.error("Error calling Ollama API:", error);
                isOllamaReachableForHeader = false; 
                updateAgentHeaderStatus();
                throw error; 
            }
        }

        function createVisualAiMessage() { 
            const timestamp = Date.now(); 
            addDateSeparator(timestamp); 

            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'ai');

            const contentDiv = document.createElement('div');
            contentDiv.classList.add('message-content');
            contentDiv.innerHTML = ''; 
            messageDiv.appendChild(contentDiv);

            const timeDiv = document.createElement('div');
            timeDiv.classList.add('message-time'); 
            messageDiv.appendChild(timeDiv);

            if(chatMessagesContainer) chatMessagesContainer.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv; 
        }

        if (sendButton && chatInput) {
            const handleSendMessage = async () => {
                if (isAiResponding) return;

                const userText = chatInput.value.trim();
                
                // Capture image data before clearing state. These are local to this function call.
                const originalImageForProcessing = currentOriginalImageBase64DataUri; // Full data URI
                const previewImageForHistory = currentResizedPreviewDataUri; // Smaller resized data URI for history
                
                const hasImageToSend = !!originalImageForProcessing;

                if (!userText && !hasImageToSend) return; 

                addNewMessage(userText, 'user', hasImageToSend, previewImageForHistory); 
                chatInput.value = '';
                chatInput.focus();

                // Clear the global state for the *next* message, now that we've used the current image data
                clearSelectedImageState(); 

                isAiResponding = true;
                setAgentStatus('typing');
                sendButton.disabled = true;
                if (attachFileBtn) attachFileBtn.disabled = true; 
                stopPeriodicOllamaHeaderCheck(); 

                let ollamaApiImagePayload = null;
                if (hasImageToSend && originalImageForProcessing) {
                    try {
                        // Resize the original image specifically for Ollama
                        const resizedForOllamaDataUri = await resizeImage(
                            originalImageForProcessing, 
                            OLLAMA_IMAGE_MAX_DIMENSION_PX, 
                            OLLAMA_IMAGE_MAX_DIMENSION_PX, 
                            IMAGE_QUALITY_OLLAMA
                        );
                        ollamaApiImagePayload = resizedForOllamaDataUri.split(',')[1]; // Get just the base64 part
                    } catch (err) {
                        console.error("Error resizing image for Ollama, attempting to send original (or part of it):", err);
                        // Fallback: try to send the original if resizing fails
                        if (originalImageForProcessing) {
                           const parts = originalImageForProcessing.split(',');
                           if (parts.length > 1) ollamaApiImagePayload = parts[1];
                        }
                    }
                }
                
                const chatHistoryString = getChatHistoryForPrompt();
                // Pass hasImageToSend to constructOllamaPrompt
                const ollamaPrompt = constructOllamaPrompt(userText, chatHistoryString, hasImageToSend);
                
                let aiMessageElement;
                let accumulatedAiResponse = ""; 
                const streamEnabled = streamResponsesToggle ? streamResponsesToggle.checked : true;

                if (streamEnabled) {
                    aiMessageElement = createVisualAiMessage(); 
                }

                try {
                    if (streamEnabled) {
                        await callOllamaApi(ollamaPrompt, (token) => { 
                            accumulatedAiResponse += token;
                            const contentDiv = aiMessageElement.querySelector('.message-content');
                            if (contentDiv) {
                                contentDiv.innerHTML = formatAiMessageContent(accumulatedAiResponse);
                            }
                            scrollToBottom();
                        }, ollamaApiImagePayload); 
                        
                        const finalTimestamp = Date.now();
                        const timeDiv = aiMessageElement.querySelector('.message-time');
                         if (timeDiv) {
                            timeDiv.textContent = new Date(finalTimestamp).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                         }
                        saveMessageToHistory({ text: accumulatedAiResponse, type: 'ai', timestamp: finalTimestamp, hasImage: false, imageBase64: null }); 

                    } else { 
                        const aiResponseText = await callOllamaApi(ollamaPrompt, () => {}, ollamaApiImagePayload); 
                        addNewMessage(aiResponseText, 'ai'); 
                    }
                    isOllamaReachableForHeader = true; 
                } catch (error) {
                    console.error("Ollama processing error:", error);
                    if (aiMessageElement && streamEnabled) { 
                        aiMessageElement.remove(); 
                    }
                    addNewMessage(getTranslation('ollamaError', { error: error.message || "Unknown error" }), 'ai');
                    isOllamaReachableForHeader = false; 
                } finally {
                    isAiResponding = false;
                    setAgentStatus('active'); 
                    sendButton.disabled = false;
                    if (attachFileBtn) attachFileBtn.disabled = false; 
                    startPeriodicOllamaHeaderCheck(); 
                }
            };

            sendButton.addEventListener('click', handleSendMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && !isAiResponding) { 
                    e.preventDefault();
                    handleSendMessage();
                }
            });
        }
        
        // --- Initial Application Load ---
        function initializeApp() {
            // Dark Mode Setting
            const savedDarkModePref = localStorage.getItem(DARK_MODE_KEY);
            setDarkMode(savedDarkModePref === 'true'); 

            // Markdown Setting
            if (markdownToggle) {
                const savedMarkdownPref = localStorage.getItem(MARKDOWN_ENABLED_KEY);
                markdownToggle.checked = savedMarkdownPref === null ? true : (savedMarkdownPref === 'true'); 
            }

            loadOllamaSettings();
            applyTranslations(); 
            loadChatHistory(); 

            if (typeof marked === 'undefined') {
                console.warn("Marked.js library is not loaded. Markdown formatting will fallback to simple newline-to-br conversion for AI messages.");
                if(markdownToggle) {
                    markdownToggle.checked = false; 
                    markdownToggle.disabled = true; // Optionally disable if lib not found
                }
            } else {
                // Configure marked for GFM line breaks (single newline = <br>)
                marked.setOptions({
                  breaks: true,
                  gfm: true,
                  pedantic: false, // Be less strict
                  smartLists: true,
                  smartypants: false
                });
            }
            
            checkOllamaForHeaderUpdate().then(() => {
                startPeriodicOllamaHeaderCheck(); 
            });
        }

        // --- Start the application ---
        initializeApp();

    </script>
</body></html>